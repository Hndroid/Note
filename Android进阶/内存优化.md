#### Java虚拟机概念

Java 虚拟机是一台 "抽象的计算机"，它拥有自己的处理器、堆栈、寄存器以及相应的指令系统；Java 虚拟机屏蔽了与具体操作系统相关的平台信息，使得 Java 程序只需要生成该虚拟机上运行的目标代码，就可以在多平台上运行；虽然叫 Java 虚拟机，但在它之上运行的语言不仅有 Java、Kotlin、Groovy、Scale 等都可以运行；

 #### Java虚拟机运行时数据区域 

 #### 强/软/弱/幻象引用

 |类型|定义|
 |:--|:--|
 |强引用|所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。|
 |软引用|软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。|
 |弱引用|弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。|
 |幻象引用|对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。|

 #### 垃圾标记算法

 |算法|定义|
 |:--|:--|
 |引用计数算法|每个对象都有一个引用计数器，当对象每被引用一次就加 1，引用失效时就减 1。当计数为 0 时则将该对象设置为可回收的 "垃圾对象"|
 |根搜索算法||
 
 #### 垃圾收集算法

 |算法|定义|
 |:--|:--|
 |标记-清除算法|顾名思义，使用根搜索算法标记可被回收的对象，之后将被标记为 "垃圾" 的对象进行回收。|
 |复制算法|先把内存一分为二，每次只使用其中一个区域，垃圾收集时，将存活的对象全部拷贝到另一个区域，然后对之前的区域进行全部回收|
 |标记-压缩算法|在标记可回收的对象后，将所有的存活的对象压缩到内存的一端，让他们排在一起，然后对边界以外的内存进行回收|
 |分代收集算法|Java 堆中存在的对象生命周期有较大差别，大部分生命周期很短，有的很长，甚至与应用程序或者 Java 虚拟机生命周期一样。因为分代算法就是根据对象的生命周期长短将放到不同的区域；|

 #### 内存泄漏/溢出

|类型|定义|
|:--|:--|
|内存泄漏|一个不再被程序使用的对象或变量依旧存活在内存中无法被回收|
|内存溢出|当程序申请内存是，没有足够的内存供程序使用|

> 比较小的内存泄漏不会有太大的影响，当内存泄漏多了，占用的内存空间就更大，程序正常需要申请使用的内存则会相应减少；

#### 内存抖动

内存抖动通常是指在短时间内发生了多次内存的分配和释放，主要原因则是短时间内频繁的创建对象，为了应对这种情况，虚拟机会频繁地触发 GC 操作，当 GC 进行时，其他线程会被挂起等待 GC 的完成，频发 GC，也就导致比如 UI 在绘制是会超过 16ms 渲染一帧，导致画面卡顿等；
